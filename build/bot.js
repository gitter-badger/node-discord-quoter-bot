// Generated by CoffeeScript 2.2.1
(function() {
  var App, CHANNEL_STRING, DISCRIMINATOR_STRING, Discord, IMAGE_EXTENSIONS, SERVER_STRING, bot, get_env, get_env_check, idt, isImage, isTrue, lg, lgErr, moment, ref, ref1, strNumberToSubscript, vars;

  lg = console.log.bind(console);

  lgErr = function(err) {
    return console.error(`${(err != null ? err.stack : void 0) || err}`);
  };

  // process.on('unhandledRejection', console.error);
  Discord = require('discord.js');

  moment = require('moment-timezone');

  ({idt, get_env, get_env_check, isTrue, strNumberToSubscript} = require('./util'));

  vars = {};

  Object.assign(vars, get_env_check(['LOCALE', 'DISCORD_BOT_TOKEN', 'DISCORD_USER_TOKEN']));

  Object.assign(vars, get_env(['PREFIX', 'DATE_FORMAT', 'TIMEZONE', 'SHOW_USER_DISCRIMINATOR', 'EMPTY_MESSAGE']));

  moment.locale(vars.LOCALE);

  DISCRIMINATOR_STRING = " #";

  CHANNEL_STRING = "in ";

  if ((ref = vars.LOCALE) === 'pt' || ref === 'pt-BR') {
    CHANNEL_STRING = "em ";
  }

  SERVER_STRING = "at ";

  if ((ref1 = vars.LOCALE) === 'pt' || ref1 === 'pt-BR') {
    SERVER_STRING = "@ ";
  }

  IMAGE_EXTENSIONS = ['jpeg', 'jpg', 'png', 'webp', 'gif'];

  isImage = function(url) {
    return IMAGE_EXTENSIONS.some(function(ext) {
      return url.endsWith('.' + ext);
    });
  };

  App = class App {
    constructor(vars1) {
      var ref2;
      // inits dedicated bot
      this.init_normal_bot = this.init_normal_bot.bind(this);
      // inits user bot
      this.init_user_bot = this.init_user_bot.bind(this);
      // sends message to user through the dedicated bot
      this.send_self_message = this.send_self_message.bind(this);
      this.buildDateString = this.buildDateString.bind(this);
      // builds a string with channel and server(guild) names and timestamp
      this.build_message_footer = this.build_message_footer.bind(this);
      // handles all sent or updated messages
      this.handle_message = this.handle_message.bind(this);
      // resends or edits a message quoting the message with ID that equals the fisrt argument (in 'args')
      this.do_quote = this.do_quote.bind(this);
      this.vars = vars1;
      this.prefix = (ref2 = this.vars.PREFIX) != null ? ref2 : "$";
      this.DATE_FORMAT = vars.DATE_FORMAT || "calendar";
      this.TIMEZONE = vars.TIMEZONE || "UTC";
      this.EMPTY_MESSAGE = vars.EMPTY_MESSAGE || "";
      this.SHOW_USER_DISCRIMINATOR = isTrue(vars.SHOW_USER_DISCRIMINATOR);
      this.init_normal_bot();
      this.init_user_bot();
    }

    init_normal_bot() {
      this.bot_client = new Discord.Client;
      this.bot_client.on('error', function(err) {
        return console.error(`${(err != null ? err.stack : void 0) || err}`);
      });
      this.bot_client.on('ready', () => {
        return console.log('Normal bot ready');
      });
      return this.bot_client.login(this.vars.DISCORD_BOT_TOKEN);
    }

    init_user_bot() {
      this.client = new Discord.Client;
      this.client.on('ready', () => {
        return console.log('User bot ready');
      });
      this.client.on('message', this.handle_message);
      this.client.on('messageUpdate', ((o, n) => {
        return this.handle_message(n);
      }));
      this.client.on('error', function(err) {
        return console.error(`${(err != null ? err.stack : void 0) || err}`);
      });
      return this.client.login(this.vars.DISCORD_USER_TOKEN);
    }

    send_self_message(txt) {
      return this.bot_client.fetchUser(this.client.user.id).then(function(user) {
        return user.sendMessage(txt);
      }, function(reason) {
        return lgErr(reason);
      });
    }

    buildDateString(timestamp) {
      if (this.DATE_FORMAT === "calendar") {
        return moment(timestamp).calendar();
      }
      return moment(timestamp).tz(this.TIMEZONE).format(this.DATE_FORMAT);
    }

    build_message_footer(message, showGuild = false) {
      var channel, footer, guild, name;
      channel = message.channel;
      footer = [];
      if ((name = channel != null ? channel.name : void 0)) {
        footer.push(CHANNEL_STRING + `\#${name}`);
      }
      if (showGuild && (guild = channel != null ? channel.guild : void 0)) {
        footer.push(`${SERVER_STRING}${(guild != null ? guild.name : void 0)}`);
      }
      footer = [footer.join(" ")].filter(idt);
      footer.push(this.buildDateString(message.createdTimestamp));
      return footer.join(" â€” ");
    }

    handle_message(message, old_message = null) {
      var args, cite, cmd;
      // only proceeds if sender is the user himself
      if (message.author.id === this.client.user.id) {
        args = message.content.split(" ");
        cmd = args.shift();
        switch (cmd) {
          case this.prefix + 'ping':
            return message.reply('pong');
          case this.prefix + 'q':
            return this.do_quote(message, args);
          case this.prefix + 'q@':
            return this.do_quote(message, args, cite = true);
        }
      }
    }

    do_quote(message, args = [], cite = false, edit = true) {
      var channel, msg_id;
      if (!(msg_id = args.shift())) {
        console.log("Missing parameter");
        return;
      }
      // TODO add message for user
      channel = message.channel;
      // search messages with given ID and returns the first one
      return channel.fetchMessages({
        limit: 1,
        around: msg_id
      }).then((qt_msg) => {
        var author_name, color, discriminator, err_msg, member, opts, ref2, res_text, showGuild;
        qt_msg = qt_msg.first();
        // if there is no message, send a error message to the user
        if (!qt_msg) {
          console.warn(`Message ID \`${msg_id}\` not found`);
          err_msg = `Message ID '${msg_id}' not found. Original message:\n`;
          err_msg += `\`${message.content}\`\n`;
          err_msg += this.build_message_footer(message, showGuild = true);
          this.send_self_message(err_msg).then((function() {
            return message.delete();
          }), function(reason) {
            return lgErr(reason);
          });
          return;
        }
        // joins the remaining arguments to make the message body
        res_text = args.join(" ");
        // checks if message is in a server (guild)
        if (channel.guild) {
          member = channel.guild.member(qt_msg.author);
          author_name = member.nickname;
          color = (ref2 = member.highestRole) != null ? ref2.color : void 0; // adiciona cor de cargo
          
          // adds a citation to quoted message's user if it's enabled
          if (cite && res_text.search(member.toString()) === -1) {
            res_text = `${member.toString()}` + (res_text ? `, ${res_text}` : "");
          }
        }
        if (author_name == null) {
          author_name = qt_msg.author.username;
        }
        if (this.SHOW_USER_DISCRIMINATOR && (discriminator = qt_msg.author.discriminator)) {
          author_name += DISCRIMINATOR_STRING + strNumberToSubscript(discriminator);
        }
        opts = {
          embed: {
            author: {
              name: author_name,
              icon_url: qt_msg.author.avatarURL
            },
            description: `${qt_msg.content}`,
            footer: {
              text: this.build_message_footer(message)
            },
            color: color,
            image: {
              url: null
            },
            fields: []
          }
        };
        (qt_msg.attachments.some(function(attachment, id) {
          var url;
          url = attachment.url;
          if (isImage(url)) {
            opts.embed.image.url = url;
            return true;
          }
        })) || (qt_msg.embeds.some(function(embed, id) {
          var ref3, url;
          if ((url = embed != null ? (ref3 = embed.thumbnail) != null ? ref3.url : void 0 : void 0)) {
            opts.embed.image.url = url;
            return true;
          }
        }));
        res_text || (res_text = this.EMPTY_MESSAGE);
        if (edit) {
          return message.edit(res_text, opts).then(function(res_message) {
            return lg(`Message updated: ${res_message.content}`);
          }, function(reason) {
            return lgErr(reason);
          });
        } else {
          return channel.sendMessage(res_text, opts).then(function(res_message) {
            lg(`Sent message: ${res_message.content}`);
            return message.delete();
          }, function(reason) {
            return lgErr(reason);
          });
        }
      }, function(reason) {
        return lgErr(reason);
      });
    }

  };

  if (!module.parent) {
    bot = new App(vars);
  } else {
    module.exports = {App};
  }

}).call(this);

//# sourceMappingURL=bot.js.map
